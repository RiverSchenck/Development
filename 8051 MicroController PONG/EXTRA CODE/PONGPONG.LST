C51 COMPILER V9.55   PONGPONG                                                              08/01/2018 15:56:25 PAGE 1   


C51 COMPILER V9.55, COMPILATION OF MODULE PONGPONG
OBJECT MODULE PLACED IN PONGPONG.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\c51.exe PONGPONG.c DB OE BR INCDIR(C:\SiLabs\MCU\Inc)

line level    source

   1          #include <C8051F020.h>
   2          #include <stdlib.h>
   3          #include <lcd.h>
   4          #include <pongheader.h>
   5          
   6          
   7          
   8          sbit BTN1 = P2^2;                       //BTN1 FOR START GAME
   9          sbit BTN2 = P2^3;
  10          unsigned char LED18;
  11          sbit LED9 = P2^4;
  12          sbit LED10 = P2^5;
  13          
  14          
  15          void main(void)
  16          {
  17   1      
  18   1      //----------------------------------
  19   1      //Init
  20   1      //-----------------------------------
  21   1              WDTCN = 0xde;// disable watch dog
  22   1              WDTCN = 0xad;
  23   1              XBR2 = 0x40; // enable port output
  24   1              XBR0 = 4;
  25   1              OSCXCN = 0x67; // TURN ON EXTERNAL CRYSTAL
  26   1              TMOD = 0x22; // wait 1ms using t1 mode2
  27   1              TH1 = -167; // 2MHZ CLOCK, 167 COUNTS - 1MS
  28   1              TR1 = 1;
  29   1              while (TF1 == 0) {} //wait 1ms
  30   1              while (!(OSCXCN & 0x80) ) {} //wait till oscillator stable
  31   1              OSCICN = 8; // switch over to 22.1184mhz
  32   1              SCON0 = 0x50; // 8-BIT, VARIABLE BAUD, RECEIVE ENABLE
  33   1              TH1 = -6;  // 9600 BAUD
  34   1              REF0CN = 0x07; // ref0 voltage
  35   1              ADC0CF = 0xf4; // GAIN
  36   1              ADC0CN = 0x80; //ENALBE AD
  37   1              IE = 0xA2;
  38   1              IP = 0x20;
  39   1              DAC0CN = 0x9C;
  40   1              T2CON = 0x00;
  41   1              TH1 = 0; //set timer 1 for a two bit timer
  42   1              TH0 = 0;
  43   1              TR0 = 1;
  44   1              TMR3CN = 4; // turn on timer 3 for ball speed
  45   1      
  46   1      
  47   1      //----------------------        
  48   1      //initializing game
  49   1      //----------------------                        
  50   1                      init_lcd();
  51   1                      blank_screen();
  52   1                      init_text();
  53   1                      get_switches();
  54   1                      init_game();
  55   1                      scores(score1, score2);
C51 COMPILER V9.55   PONGPONG                                                              08/01/2018 15:56:25 PAGE 2   

  56   1      
  57   1      //----------------------        
  58   1      //Playing game
  59   1      //----------------------
  60   1              while(BTN2 == 1) {
  61   2      
  62   2      
  63   2                      //SHOW SCORE LOOP. IE AFTER A POINT IS SCORED
  64   2                      while(show_score == 0) {
  65   3                                      scores(score1, score2);
  66   3                                      onemillidelay(2000);//DELAY TO SHOW THE SCORE OF THE GAME
  67   3                                      get_switches();
  68   3                                      draw_ball(ball_x, ball_y);
  69   3                                      show_score = 1;
  70   3                              }
  71   2                              //PLAYING GAME LOOP
  72   2                              while(show_score == 1 && BTN2 == 1)
  73   2                              {
  74   3      
  75   3                                              //CHECKS TO SEE IF SOMEONE HAS WON
  76   3                                              if(score1 < 11 && score2 < 11) {
  77   4      
  78   4                                              blank_screen();                         
  79   4                                              init_game();                    
  80   4                                              get_switches(); 
  81   4                                              move_comps();
  82   4                                              draw_ball(ball_x, ball_y);
  83   4                                                      while ((TMR3CN & 0x80) ==0)
  84   4                                                      {
  85   5                                                      }
  86   4                                                      TMR3CN &= 0x7F;
  87   4                                                      speed();
  88   4                                                      refresh_screen();                                               
  89   4                                                      
  90   4                                              }                                                                        
  91   3                                              else if(score1 == 11 || score2 == 11)
  92   3                                              {
  93   4                                                      winner();
  94   4                                                      return;
  95   4                                              }//end else if
  96   3      
  97   3                                      
  98   3              
  99   3                              }//end while
 100   2              
 101   2              }//end for
 102   1      
 103   1      }//end main
 104          
 105          
 106          
 107          
 108          //==============================================================================
 109          //TIMER_0
 110          //Variables: count, random[], serve[], rise, run, ball_x, ball_y
 111          //Function Calls: none
 112          //picks a random number from serve[] & random[] for random serve and random angle
 113          //==============================================================================
 114          
 115          void timer_0(void) interrupt 1
 116          {
 117   1              if(count < 3)//parses through 4 possible
C51 COMPILER V9.55   PONGPONG                                                              08/01/2018 15:56:25 PAGE 3   

 118   1              {       
 119   2                      rise = random[count];
 120   2                      ball_x = serve[count];
 121   2                      count++;                        
 122   2              }
 123   1              else if(count == 3)
 124   1              {
 125   2                      rise = random[count];
 126   2                      count = 0;                      
 127   2              }
 128   1      
 129   1      
 130   1              if(ball_x ==110) { //if random picks 110 make ball move left
 131   2                      run = -1;
 132   2              }
 133   1              else{
 134   2                      run = 1;//if randm picks 8 make ball move right
 135   2              }
 136   1              ball_y = 30;//serve from 30 y coordinate
 137   1      
 138   1      }
 139          
 140          
 141          //==============================================================================
 142          //TIMER2
 143          //Variables: phase, sine[], duration, TR2
 144          //Function Calls: none
 145          //this function is the sound interrupt
 146          //==============================================================================
 147          void timer2(void) interrupt 5
 148          {
 149   1      
 150   1                      TF2 = 0;
 151   1                      DAC0H = sine[phase];
 152   1                      if ( phase < sizeof(sine)-1 )   // if mid-cycle
 153   1                      {                               // complete it
 154   2                              phase++;
 155   2                      }
 156   1                      else if ( duration > 0 )        // if more cycles left to go
 157   1                      {                               // start a new cycle
 158   2                              phase = 0;
 159   2                              duration--;
 160   2                      }
 161   1                      if ( duration == 0)
 162   1                      {
 163   2                              TR2 = 0;
 164   2                      }
 165   1              
 166   1      }
 167          
 168          
 169          
 170          //==============================================================================
 171          //ONEMILLIDELAY
 172          //Variables: i, j
 173          //Function Calls: none
 174          //delay of i time, from the book. ie(int time = 2000 -> 2 second delay)
 175          //==============================================================================
 176          void onemillidelay(unsigned int time) 
 177          {
 178   1      unsigned int i; 
 179   1      unsigned int j; 
C51 COMPILER V9.55   PONGPONG                                                              08/01/2018 15:56:25 PAGE 4   

 180   1              for(i=0; i<time; i++){ //looping to create a delay
 181   2                      for(j=0; j<1843; j++){
 182   3                      }
 183   2              }
 184   1      }
 185          
 186          
 187          //==============================================================================
 188          //PUT_CHAR
 189          //Variables:
 190          //Function Calls: none
 191          //inserts characters onto the lcd screen using lcd.h and lcd_driver.asm
 192          //==============================================================================
 193          unsigned char put_char (unsigned char row, unsigned char col, char ch) {
 194   1                      int loc = row * 128 + col; 
 195   1                      int font = (ch - ' ') * 5; //*5 because each letter has 5 hex values
 196   1                      char i;
 197   1                      for (i=0; i<5; i++) //print 5 hex values
 198   1                      {
 199   2                              screen[loc +i] = font5x8[font+i];
 200   2                      }
 201   1                      return (0);
 202   1      }
 203          
 204          
 205          
 206          //==============================================================================
 207          //INIT_GAME
 208          //Variable: i, soccer
 209          //Function Calls: soccermode(),
 210          //draws the bounds for the game and decides if it is in soccer mode or not (switch 5)
 211          //==============================================================================
 212          void init_game () {
 213   1      
 214   1                      unsigned int i;
 215   1                      //TOP BOUNDARY
 216   1                      for(i=0; i<127; i++) {
 217   2                              screen[i] = 0x03; 
 218   2                      }
 219   1                      //BOTTOM BOUNDARY
 220   1                      for(i=0; i<127; i++) {
 221   2                              screen[896+i] = 0xC0; 
 222   2                      }
 223   1      
 224   1                      //-----------------------
 225   1                      //SOCCER MODE
 226   1                      //-----------------------
 227   1                      if (soccer == 0) {
 228   2                              soccermode();
 229   2      
 230   2      
 231   2                      }
 232   1                      else {
 233   2                              //NET
 234   2                              screen[63] = 0xCF;
 235   2                              screen[64] = 0xCF;
 236   2                              for(i=191; i<960; i++) {
 237   3                                      screen[i+1] = 0xCC;
 238   3                                      screen[i] = 0xCC; 
 239   3                                      i= i+127;
 240   3                              }
 241   2      
C51 COMPILER V9.55   PONGPONG                                                              08/01/2018 15:56:25 PAGE 5   

 242   2                      }
 243   1      }
 244          
 245          
 246          
 247          //==============================================================================
 248          //INIT_TEXT
 249          //Variable:
 250          //Funcation Calls: put_char(), blank_screen(), refresh_screen(), get_switches()
 251          //Prints HELLO PRESS START TO PLAY! and waits for user to press start
 252          //==============================================================================
 253          void init_text(void) {
 254   1      
 255   1                      put_char(1,0, 'H'); put_char(1,6, 'E'); put_char(1,12,'L');     put_char(1,18,'L'); //displays HELLO
 256   1                      put_char(1,24,'O'); put_char(1,32,' ');
 257   1      
 258   1                      put_char(1,38,'P'); put_char(1,44,'R'); put_char(1,50,'E'); put_char(1,56,'S'); //displays PRESS
 259   1                      put_char(1,62,'S'); put_char(1,68,' '); 
 260   1              
 261   1                      put_char(1,74,'S'); put_char(1,80,'T'); put_char(1,84,'A'); put_char(1,90,'R'); //displays START TO
 262   1                      put_char(1,96,'T'); put_char(1,102,' '); put_char(1,108,'T'); put_char(1,114,'O'); 
 263   1      
 264   1                      put_char(3,52, 'P'); put_char(3,58, 'L'); put_char(3,64, 'A'); put_char(3,70, 'Y'); //PLAY!
 265   1                      put_char(3,76,'!');     put_char(6,30,' ');     put_char(6,36,' '); put_char(6,42,' ');
 266   1      
 267   1                      refresh_screen();
 268   1                      while(BTN1) {           //waits until BTN1 is pressed to continue
 269   2      
 270   2                      }
 271   1                      blank_screen();//reset screen
 272   1      
 273   1      
 274   1                      TR0 = 0;
 275   1                      get_switches(); 
 276   1      }
 277          
 278          
 279          
 280          //==============================================================================
 281          //GET_SWITCHES
 282          //Variables: switches, paddle1, paddle1top, paddle1height, paddleheight,
 283          //paddle2, paddle2top, paddle2height
 284          //gets the input of the switches and passes them to the paddle function
 285          //==============================================================================
 286          void get_switches(){
 287   1      
 288   1                              switches = ~P3;                                                 //inverts P3 so all 0
 289   1                              switches &= 0x03;                                               //ANDING paddle1 with 0x03 to mask
 290   1                              paddle1 = switches;                                             //all switches except 1 and 2
 291   1                              draw_paddle (0, paddle1top, paddle1);   
 292   1                              paddle1height = height;
 293   1                      
 294   1                              switches = ~P3;                                                 //inverts p3 so all 0
 295   1                              switches &= 0x0c;                                               //ANDING paddle2 with 0x0C to mask
 296   1                              paddle2 = switches >> 2;                                //all switches excpet 3 and 4. Shifts 2 to right to get number  
 297   1                              draw_paddle (126, paddle2top, paddle2); // or else it would be 00001100 and we would get wrong values
 298   1                              paddle2height = height;                                         
 299   1      
 300   1      
 301   1                              soccer = ~P3;                                                   //inverts p3 so all 0
 302   1                              soccer &= 0x10;                                                 //ANDING soccer with 0x10 to mask
 303   1                              soccer = soccer >> 4;                                   //all switches expect 5. Shifting 4 to right to get number
C51 COMPILER V9.55   PONGPONG                                                              08/01/2018 15:56:25 PAGE 6   

 304   1      
 305   1      }
 306          
 307          
 308          
 309          //==============================================================================
 310          //SOUND
 311          //Variables: sound, RCAP2H, RCAP2L, TR2, duration
 312          //Function Calls: none
 313          //produces a noise based on where the ball hits. We pass a number into this 
 314          //function and it will produce a noise depending on what number is passed in.
 315          //==============================================================================
 316          void sound(int sound){
 317   1      
 318   1              if(sound == 1) {                                //sound one is played at 600Hz
 319   2                      RCAP2H = (-307)>>8; //high
 320   2                      RCAP2L = -307;          //low
 321   2                      TR2 = 1; 
 322   2                      duration = 60;
 323   2              }
 324   1              
 325   1              if(sound == 2) {                                //sound two is played at 800Hz
 326   2                      RCAP2H = (-230)>>8; //high
 327   2                      RCAP2L = -230;          //low
 328   2                      TR2 = 1; 
 329   2                      duration = 80;
 330   2              }
 331   1      
 332   1              if(sound ==3) {                                 //sound three is played at 400Hz
 333   2                      RCAP2H = (-460)>>8; //high
 334   2                      RCAP2L = -460;          //low
 335   2                      TR2 = 1; 
 336   2                      duration = 40;
 337   2              }
 338   1      }
 339          
 340          
 341          
 342          //==============================================================================
 343          //MOVE_COMPS
 344          //Variables: bally, ballx, left_hit1, left_hit2, left_hit3, left_hit4, right_hit1
 345          //right_hit2, right_hit3, right_hit4, paddle1height, paddle1top, paddle2height
 346          //paddle2top
 347          //gets input from the pots and moves the ball
 348          //==============================================================================
 349          void move_comps(void) {
 350   1      
 351   1              //BALL COORDINATES
 352   1              char bally, ballx;
 353   1              //LEFT 4 PADDLE HIT SPOTS
 354   1              char left_hit1 = (paddle1height/4)+paddle1top;
 355   1              char left_hit2 = (paddle1height/4*2)+paddle1top;
 356   1              char left_hit3 = (paddle1height/4*3)+paddle1top;
 357   1              char left_hit4 = paddle1height+paddle1top;
 358   1              //RIGHT 4 PADDLE HIT SPOTS
 359   1              char right_hit1 = (paddle2height/4)+paddle2top;
 360   1              char right_hit2 = (paddle2height/4*2)+paddle2top;
 361   1              char right_hit3 = (paddle2height/4*3)+paddle2top;
 362   1              char right_hit4 = paddle2height+paddle2top;
 363   1      
 364   1              //-------------------
 365   1              //GET POT INPUT
C51 COMPILER V9.55   PONGPONG                                                              08/01/2018 15:56:25 PAGE 7   

 366   1              //-------------------
 367   1              AMX0SL = 0x00;  //Select ain0
 368   1              onemillidelay(4);
 369   1              ADC0CF = 0x40;
 370   1              AD0INT = 0;     //clear flag
 371   1              AD0BUSY = 1;                    
 372   1              while(AD0INT == 0){}    
 373   1              paddle1top = ADC0H*4; //so we get value out of 64       
 374   1                                                                      
 375   1              AMX0SL = 0x01; //select ain1    
 376   1              onemillidelay(4);
 377   1              ADC0CF = 0x40;
 378   1              AD0INT = 0;    //clear flag
 379   1              AD0BUSY = 1; 
 380   1              while(AD0INT == 0) 
 381   1              {}
 382   1              paddle2top = ADC0H*4;//so we get value out of 64        
 383   1              
 384   1      
 385   1                      //---------------------
 386   1                      //MOVE THE BALL
 387   1                      //---------------------
 388   1                      ball_x += run;          
 389   1                      ball_y += rise; 
 390   1                      
 391   1                      ballx = ball_x+2; //so we know where the edges of the ball are
 392   1                      bally = ball_y+2; //ball_x and ball_y are the center of the ball
 393   1      
 394   1                      //----------------------------------      
 395   1                      //HITTING TOP OR BOTTOM
 396   1                      //----------------------------------
 397   1                      if (bally < 2 || bally > 61) {
 398   2                      rise = -rise; 
 399   2                      sound(1); //INVERT TO MOVE OPPOSITE
 400   2                      }  
 401   1                      else{ 
 402   2                      rise = rise;
 403   2                      }       
 404   1                                                      
 405   1              //---------------------------------               
 406   1              //LEFT PADDLE
 407   1              //---------------------------------
 408   1              if (ballx < 3){ 
 409   2      
 410   2                      //-----FULL PADDLE-----
 411   2                      if (paddle1 == 3){
 412   3                      run = -run; //INVERT DIRECTION AUTOMATICALLY BECAUSE NO MATTER WHERE IT HITS IT WILL BOUNCE BACK
 413   3                      sound(1); 
 414   3                      } 
 415   2                      //-----TOP QUAD-----                                                                    
 416   2                      else if (bally >= paddle1top && bally <= left_hit1) {
 417   3                      rise = -2; //STEEP ANGLE UP
 418   3                      run = 1; 
 419   3                      sound(2);
 420   3                      }
 421   2                      //-----THIRD QUAD-----
 422   2                      else if (bally >= left_hit1 && bally <= left_hit2){
 423   3                      rise = -1; //SHALLOW ANGLE UP
 424   3                      run = 2; 
 425   3                      sound(2);
 426   3                      }
 427   2                      //-----SECOND QUAD-----
C51 COMPILER V9.55   PONGPONG                                                              08/01/2018 15:56:25 PAGE 8   

 428   2                      else if (bally >= left_hit2 && bally <= left_hit3){
 429   3                      rise = 1; //SHALLOW ANGLE DOWN
 430   3                      run = 2; 
 431   3                      sound(2);
 432   3                      }
 433   2                      //-----FIRST QUAD-----
 434   2                      else if (bally >= left_hit3 && bally <= left_hit4){
 435   3                      rise = 2; //STEEP ANGLE DOWN
 436   3                      run = 1; 
 437   3                      sound(2);
 438   3                      }
 439   2                      //-----MISS-----
 440   2                      else {
 441   3                      score2++;                       //add 1 to score
 442   3                      show_score = 0;         //score loop is 0 so it shows score
 443   3                      ball_x = 110;           //set serve location
 444   3                      ball_y = 30;            //set serve location
 445   3                      run = -1; 
 446   3                      rise = 1; 
 447   3                      //---LED BLINKING---
 448   3                              P1 = 0x00;
 449   3                              LED9 = 0;
 450   3                              LED10 = 0;
 451   3                              sound(3);
 452   3                              onemillidelay(500);
 453   3                              P1 = 0xFF;
 454   3                              LED9 = 1;
 455   3                              LED10 = 1;
 456   3                      }//end else
 457   2              refresh_screen();
 458   2              }//end if 
 459   1      
 460   1              //---------------------------------               
 461   1              //RIGHT PADDLE
 462   1              //---------------------------------
 463   1              if (ballx > 123)
 464   1              {       
 465   2                      //-----FULL PADDLE-----
 466   2                      if (paddle2 == 3){
 467   3                      run = -run; //INVERT DIRECTION AUTOMATICALLY BECAUSE NO MATTER WHERE IT HITS IT WILL BOUNCE BACK
 468   3                      sound(1);
 469   3                      }
 470   2                      //-----TOP QUAD-----
 471   2                      else if (bally >= paddle2top && bally <= right_hit1){
 472   3                      rise = -2; //STEEP ANGLE UP
 473   3                      run = -1; 
 474   3                      sound(2);
 475   3                      }
 476   2                      //-----THIRD QUAD-----
 477   2                      else if (bally >= right_hit1 && bally <= right_hit2) {
 478   3                      rise = -1; //SHALLOW ANGLE UP
 479   3                      run = -2; 
 480   3                      sound(2);
 481   3                      }
 482   2                      //-----SECOND QUAD-----
 483   2                      else if (bally >= right_hit2 && bally <= right_hit3){
 484   3                      rise = 1; //SHALLOW ANGLE DOWN
 485   3                      run = -2; 
 486   3                      sound(2);
 487   3                      }
 488   2                      //-----FULL PADDLE-----
 489   2                      else if (bally >= right_hit3 && bally <= right_hit4){
C51 COMPILER V9.55   PONGPONG                                                              08/01/2018 15:56:25 PAGE 9   

 490   3                      rise = 2; 
 491   3                      run = -1;
 492   3                      sound(2);
 493   3                      } 
 494   2                      //-----MISS-----
 495   2                      else {
 496   3                      score1++;                       //add 1 to score
 497   3                      show_score = 0;         //set score loop to 0 to show score
 498   3                      ball_x = 8;             //set serve location
 499   3                      ball_y = 30;            //set serve location
 500   3                      run = 1; 
 501   3                      rise = 1; 
 502   3                      //---LED BLINKING---
 503   3                              P1 = 0x00;
 504   3                              LED9 = 0;
 505   3                              LED10 = 0;
 506   3                              sound(3);
 507   3                              onemillidelay(500);
 508   3                              P1 = 0xFF;
 509   3                              LED9 = 1;
 510   3                              LED10 = 1;
 511   3                      }
 512   2              }
 513   1      
 514   1              
 515   1      }
 516          
 517          
 518          //==============================================================================
 519          //DISPLAY SCORES
 520          //Variables: font, font2, soccer
 521          //Funcation Calls: soccermode, put_char
 522          //This function displays the scores. It multiplies the score by 5 so we get the 
 523          //correct values from the screen[] table. It also checks if soccermode is enabled
 524          //and will display P1 and P2 with score if not, USA and ITALY and score if enabled
 525          //==============================================================================
 526          void scores (char score1, char score2) 
 527          {
 528   1      
 529   1                      int font = (score1)*5;
 530   1                      int font2;
 531   1                      char i;
 532   1                              if(score1 >=10){                                //this is for the first digit in the score '0'1
 533   2                                      font2 = 5;                                      //we dont have double digit numbers in the font5x8
 534   2                                      font = (((font/5)-10)*5);       //so we make a new variable, font2 and make it display 1 if over 10
 535   2                              }                                                               //then we make the font number reset 
 536   1                              else {
 537   2                                      font2 = 0;
 538   2                              }
 539   1      
 540   1      
 541   1                                      for (i=0; i<5; i++)
 542   1                                      {
 543   2                                              screen[304+i] = score5x8[font+i];
 544   2                                              screen[298+i] = score5x8[font2+i];
 545   2                                                      //FOR SOCCER MODE
 546   2                                                      if(soccer==1) {                 
 547   3                                                              put_char(1,42,'P');                     //Displays p1 if not soccer mode
 548   3                                                              put_char(1,48,'1');
 549   3                                                      }
 550   2                                                      else if(soccer==0){
 551   3                                                              put_char(1,42, 'U');            //Displays USA if sovvermode is enabled
C51 COMPILER V9.55   PONGPONG                                                              08/01/2018 15:56:25 PAGE 10  

 552   3                                                              put_char(1,48, 'S');
 553   3                                                              put_char(1,54, 'A');
 554   3                                                      }
 555   2                                      }
 556   1                      font = (score2)*5;
 557   1                              if(score2 >=10){                                        //this is for the first digit in the score '0'1
 558   2                                      font2 = 5;                                              //we dont have double digit numbers in the font5x8
 559   2                                      font = (((font/5)-10)*5);               //so we make a new variable, font2 and make it display 1 if over 10
 560   2                              }                                                                       //then we make the font number reset 
 561   1                              else {
 562   2                                      font2 = 0;
 563   2                              }
 564   1                                      for (i=0; i<5; i++)
 565   1                                      {
 566   2                                              screen[336+i] = score5x8[font+i];
 567   2                                              screen[330+i] = score5x8[font2+i];
 568   2                                                      //FOR SOCCER MODE
 569   2                                                      if(soccer==1) {                         //display P2 if not soccermode
 570   3                                                              put_char(1,74,'P');
 571   3                                                              put_char(1,80,'2');
 572   3                                                      }
 573   2                                                      else if(soccer==0){
 574   3                                                              put_char(1,70, 'I');    //display ITALY if soccermode is enabled
 575   3                                                              put_char(1,76, 'T');
 576   3                                                              put_char(1,82, 'A');
 577   3                                                              put_char(1,88, 'L');
 578   3                                                              put_char(1,94, 'Y');
 579   3                                                      }
 580   2      
 581   2                                      }//end for
 582   1                      refresh_screen();               
 583   1      }
 584          
 585          
 586          
 587          
 588          //==============================================================================
 589          //WINNER
 590          //Variables: none
 591          //Function Calls: blank_screen, init_game, scores, put_char, refresh_screen
 592          //onemillidelay
 593          //This is the winning function. It is called when a player reaches the score of
 594          //11. It will display WINNER then blink the LEDS.
 595          //==============================================================================
 596          void winner(void) {
 597   1                              int i;
 598   1                              blank_screen();
 599   1                              init_game();
 600   1                              scores(score1, score2); //Display the score to see what end result was
 601   1                              put_char(4,48, 'W'); put_char(4,54, 'I'); put_char(4,60,'N');   put_char(4,66,'N'); //displays WINNER
 602   1                              put_char(4,72,'E'); put_char(4,78,'R'); put_char(4,84, '!');
 603   1                              refresh_screen();
 604   1                              
 605   1      
 606   1                              for(i=0;i<5;i++) {
 607   2                              //---LED BLINKING---
 608   2                                      P1 = 0x00;
 609   2                                      LED9 = 0;
 610   2                                      LED10 = 0;
 611   2                                      sound(3);
 612   2                                      onemillidelay(500);
 613   2                                      P1 = 0xFF;
C51 COMPILER V9.55   PONGPONG                                                              08/01/2018 15:56:25 PAGE 11  

 614   2                                      LED9 = 1;
 615   2                                      LED10 = 1;
 616   2      
 617   2                              }
 618   1                              onemillidelay(2000);
 619   1      }
 620          
 621          
 622          
 623          //==============================================================================
 624          //SOCCERMODE
 625          //Variables: i
 626          //Function Calls:
 627          //Draws a soccer field on the lcd screen.
 628          //==============================================================================
 629          void soccermode(void) {
 630   1              int i; 
 631   1      
 632   1              for(i=63; i<960; i++) {
 633   2                      screen[i+1] = 0xFF; 
 634   2                      i= i+127;
 635   2              }
 636   1      
 637   1              //LEFT GOAL
 638   1              for(i=256; i<276; i++) {
 639   2                      screen[i] = 0x1;
 640   2              }
 641   1              for(i=768; i<788; i++) {
 642   2                      screen[i] = 0x1;
 643   2              }
 644   1              for(i=275; i<768; i++) {
 645   2                      screen[i] = 0xFF;
 646   2                      i = i+127;
 647   2              }
 648   1      
 649   1              //RIGHT GOAL
 650   1              for(i=363; i<383; i++) {
 651   2                      screen[i] = 0x1;
 652   2              }
 653   1              for(i=875; i<895; i++) {
 654   2                      screen[i] = 0x1;
 655   2              }
 656   1              for(i=363; i<875; i++) {
 657   2                      screen[i] = 0xFF;
 658   2                      i = i+127;
 659   2              }
 660   1      
 661   1              //CENTER 
 662   1              for(i=449;i<459;i++){
 663   2              screen[i] = 0x01;
 664   2              screen[i+256] = 0x01;
 665   2              }
 666   1              for(i=438;i<448;i++){
 667   2              screen[i] = 0x01;
 668   2              screen[i+256] = 0x01;
 669   2              }
 670   1              for(i=438;i<689;i++){
 671   2              screen[i] = 0xFF;
 672   2              screen[i+20] = 0xFF;
 673   2              i=i+127;
 674   2              }
 675   1      
C51 COMPILER V9.55   PONGPONG                                                              08/01/2018 15:56:25 PAGE 12  

 676   1      }
 677          
 678          
 679          //==============================================================================
 680          //SPEED
 681          //Variables: ballspeed, TMR3RLH
 682          //Function Calls: 
 683          //gets input from the pots and moves the ball. Uses timer 2.
 684          //==============================================================================
 685          void speed() {
 686   1      
 687   1                      
 688   1                      ballspeed = ~P3;
 689   1                      ballspeed &= 0xc0;                      //ANDs ballspeed and 0xc0 so we can see switches 7 and 8
 690   1                      ballspeed = ballspeed >> 6; //shift so we get accurate numbers
 691   1                      
 692   1      
 693   1                      if(ballspeed==-01) {
 694   2                      //sound(1);
 695   2                              TMR3RLH = (-100000)>>8; //100 pixels per second
 696   2                              TMR3RLL = -100000;
 697   2                      }
 698   1                      else if(ballspeed==-02) {
 699   2                      //sound(2);
 700   2                              TMR3RLH = (-50000)>>8;  //slow speed
 701   2                              TMR3RLL = -50000;
 702   2                      }
 703   1                      else if(ballspeed==00) {
 704   2                      //sound(3);
 705   2                              TMR3RLH = (-12288)>>8;  //150 pixels per second
 706   2                              TMR3RLL = -12288;
 707   2                      }
 708   1                      else if(ballspeed==01) {
 709   2                      //sound(1);
 710   2                              TMR3RLH = (-9216)>>8;   //200 pixels per second
 711   2                              TMR3RLL = -9216;
 712   2                      }
 713   1              
 714   1      }
 715          
 716          //==============================================================================
 717          //DRAW_PADDLE
 718          //Variables: mask, tmp, side, height, paddle, bottom, top
 719          //Function Calls: none
 720          //Draws the paddles. Finds if the paddle is 8, 12, 16, or 64 pixels. Then makes 
 721          //sure paddle stays in screen limit. Then ORs screen with mask.
 722          //==============================================================================
 723          void draw_paddle (int side, int tmp, char paddle) {
 724   1      
 725   1                      long mask;
 726   1                      if(paddle == 0) {
 727   2                              if(tmp>54) {
 728   3                                       tmp = group[5];
 729   3                              }                                                       //paddle = 0 makes the paddle 8 pixels
 730   2                              mask = maskit[1];                        
 731   2                              height = group[0];      
 732   2                      }
 733   1                      else if(paddle == group[8]) {
 734   2                              if(tmp>group[6]){
 735   3                                      tmp = group[6]; 
 736   3                              }                                                       //paddle = 1 makes the paddle 12 pixels
 737   2                              mask = maskit[2];                       
C51 COMPILER V9.55   PONGPONG                                                              08/01/2018 15:56:25 PAGE 13  

 738   2                              height = group[1];      
 739   2                      }
 740   1                      else if(paddle == group[9]) {   
 741   2                              if(tmp > group[7]) {
 742   3                                      tmp= group[7];
 743   3                              }                                                       //paddle = 2 makes the paddle 16 pixels
 744   2                              mask = maskit[3];                        
 745   2                              height = group[2];      
 746   2                      }
 747   1                      else if(paddle == group[10]) {
 748   2                              while(side<1024)                                //paddle = 3 makes the paddle 64 pixels
 749   2                              {                                                       
 750   3                                      screen[side] = maskit[1];               //we need to make the paddle 64 so this loop displays it
 751   3                                  screen[side+1] = maskit[1];
 752   3                                      side = side+128;
 753   3                              }                               
 754   2                                                              //top is 2 pixels because the wall is above it
 755   2                                      bottom = group[3];      //
 756   2                                      height = group[3];
 757   2                                      top = group[3]; 
 758   2                              }
 759   1                      
 760   1              if (tmp<group[4]) {
 761   2                      tmp =group[4];
 762   2              }                                                               
 763   1              mask = mask <<(tmp%8);                  
 764   1              side += (tmp/8)*128;    
 765   1              top = tmp;
 766   1              bottom = tmp+height-1;                                  //apply the mask on the screen
 767   1              screen[side] |= mask;                                   //modulus 8 to select correct page
 768   1              screen[side+1] |= mask;                                 
 769   1              screen[side+128] |= mask >> group[0];           
 770   1              screen[side+129] |= mask >> group[0];   
 771   1              screen[side+256] |= mask >> group[2];   
 772   1              screen[side+257] |= mask >> group[2];
 773   1      }
 774          
 775          
 776          //==============================================================================
 777          //draw_ball
 778          //Variables: mask, i, j
 779          //Function Calls: 
 780          //Masks the ball and draws it on the screen
 781          //==============================================================================
 782          void draw_ball (int side, int tmp)
 783          {
 784   1              long mask = maskit[0] << (tmp%8);               //make a 5 pixel tall mask                                        
 785   1              int j = (tmp/group[0])*128+side;                //divide by 8 then add side to get in right place vertically                                    
 786   1              int i;
 787   1      
 788   1              for (i = 0; i<5; ++i) //this loop to make it 5 pixels wise
 789   1              { 
 790   2                      screen[j] |= mask; 
 791   2                      screen[j+128] |= mask >>group[0];
 792   2                      j++; 
 793   2              }
 794   1      }
 795          
 796          
 797          


C51 COMPILER V9.55   PONGPONG                                                              08/01/2018 15:56:25 PAGE 14  

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3274    ----
   CONSTANT SIZE    =     16    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     68      40
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
